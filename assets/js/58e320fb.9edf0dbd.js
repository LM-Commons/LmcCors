"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[962],{256:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=s(4848),o=s(8453);const r={},i="Guide",l={id:"guide",title:"Guide",description:"Event registration",source:"@site/docs/03-guide.md",sourceDirName:".",slug:"/guide",permalink:"/LmcCors/docs/guide",draft:!1,unlisted:!1,editUrl:"https://github.com/lm-commons/lmccors/tree/master/docs/docs/03-guide.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/LmcCors/docs/installation"}},a={},c=[{value:"Event registration",id:"event-registration",level:2},{value:"Configuring the module",id:"configuring-the-module",level:2},{value:"Preflight request",id:"preflight-request",level:2},{value:"Actual request",id:"actual-request",level:2},{value:"Security concerns",id:"security-concerns",level:2},{value:"Custom schemes",id:"custom-schemes",level:2},{value:"Example",id:"example",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"guide",children:"Guide"}),"\n",(0,t.jsx)(n.h2,{id:"event-registration",children:"Event registration"}),"\n",(0,t.jsxs)(n.p,{children:["LmcCors registers the ",(0,t.jsx)(n.code,{children:"LmcCors\\Mvc\\CorsRequestListener"})," with the ",(0,t.jsx)(n.code,{children:"MvcEvent::EVENT_ROUTE"})," event, with a priority\nof -1. This means that this listener is executed AFTER the route has been matched."]}),"\n",(0,t.jsx)(n.h2,{id:"configuring-the-module",children:"Configuring the module"}),"\n",(0,t.jsx)(n.p,{children:"As by default, all the various options are set globally for all routes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"allowed_origins"}),": (array) List of allowed origins. To allow any origin, you can use the wildcard (",(0,t.jsx)(n.code,{children:"*"}),") character. If\nmultiple origins are specified, LmcCors will automatically check the ",(0,t.jsx)(n.code,{children:'"Origin"'})," header's value, and only return the\nallowed domain (if any) in the ",(0,t.jsx)(n.code,{children:'"Allow-Access-Control-Origin"'})," response header. To allow any sub-domain, you can prefix\nthe domain with the wildcard character (i.e. ",(0,t.jsx)(n.code,{children:"*.example.com"}),'). Please note that you don\'t need to\nadd your host URI (so if your website is hosted as "example.com", "example.com" is automatically allowed.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"allowed_methods"}),": (array) List of allowed HTTP methods. Those methods will be returned for the preflight request to\nindicate which methods are allowed to the user agent. You can even specify custom HTTP verbs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"allowed_headers"}),": (array) List of allowed headers that will be returned for the preflight request. This indicates\nto the user agent which headers are permitted to be sent when doing the actual request."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"max_age"}),": (int) Maximum age (seconds) the preflight request should be cached by the user agent. This prevents the\nuser agent from sending a preflight request for each request."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exposed_headers"}),": (array) List of response headers that are allowed to be read in the user agent. Please note that\nsome browsers do not implement this feature correctly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"allowed_credentials"}),": (boolean) If true, it allows the browser to send cookies along with the request."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to configure specific routes, you can add ",(0,t.jsx)(n.code,{children:"LmcCors\\Options\\CorsOptions::ROUTE_PARAM"})," to your route configuration:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"<?php\n\nreturn [\n    'lmc_cors' => [\n        'allowed_origins' => ['*'],\n        'allowed_methods' => ['GET', 'POST', 'DELETE'],\n    ],\n    'router' => [\n        'routes' => [\n            'readOnlyRoute' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/foo/bar',\n                    'defaults' => [\n                        // This will replace allowed_methods configuration to only allow GET requests\n                        // and only allow a specific origin instead of the wildcard origin\n                        LmcCors\\Options\\CorsOptions::ROUTE_PARAM => [\n                            'allowed_origins' => ['http://example.org'],\n                            'allowed_methods' => ['GET'],\n                        ],\n                    ],\n                ],\n            ],\n            'someAjaxCalls' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/ajax',\n                    'defaults' => [\n                        // This overrides the wildcard origin\n                        LmcCors\\Options\\CorsOptions::ROUTE_PARAM => [\n                            'allowed_origins' => ['http://example.org'],\n                        ],\n                    ],\n                ],\n                'may_terminate' => false,\n                'child_routes' => [\n                    'blog' => [\n                        'type' => 'literal',\n                        'options' => [\n                            'route' => '/blogpost',\n                            'defaults' => [\n                                // This would only allow `http://example.org` to GET this route\n                                \\LmcCors\\Options\\CorsOptions::ROUTE_PARAM => [\n                                    'allowed_methods' => ['GET'],\n                                ],\n                            ],\n                        ],\n                        'may_terminate' => true,\n                        'child_routes' => [\n                            'delete' => [\n                                'type' => 'segment',\n                                'options' => [\n                                    'route' => ':id',\n                                    // This would only allow origin `http://example.org` to apply DELETE on this route\n                                    'defaults' => [\n                                        \\LmcCors\\Options\\CorsOptions::ROUTE_PARAM => [\n                                            'allowed_methods' => ['DELETE'],\n                                        ],\n                                    ],\n                                ],\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n"})}),"\n",(0,t.jsx)(n.h2,{id:"preflight-request",children:"Preflight request"}),"\n",(0,t.jsx)(n.p,{children:"If LmcCors detects a preflight CORS request, a new HTTP response will be created, and LmcCors will send the appropriate\nheaders according to your configuration. The response will always be sent with a 200 status code (OK)."}),"\n",(0,t.jsxs)(n.p,{children:["Please note that this will also prevent further MVC steps from being executed, since all subsequent MVC steps are\nskipped till ",(0,t.jsx)(n.code,{children:"Laminas\\Mvc\\MvcEvent::EVENT_FINISH"}),", which is responsible for actually sending the response."]}),"\n",(0,t.jsx)(n.h2,{id:"actual-request",children:"Actual request"}),"\n",(0,t.jsx)(n.p,{children:"When an actual request is made, LmcCors first checks it the origin is allowed. If it is not, then a new response with\na 403 status code (Forbidden) is created and sent."}),"\n",(0,t.jsxs)(n.p,{children:["Please note that this will also prevent further MVC steps from being executed, since all subsequent MVC steps are\nskipped till ",(0,t.jsx)(n.code,{children:"Laminas\\Mvc\\MvcEvent::EVENT_FINISH"}),", which is responsible for actually sending the response."]}),"\n",(0,t.jsxs)(n.p,{children:["If the origin is allowed, LmcCors will just add the appropriate headers to the request produced by ",(0,t.jsx)(n.code,{children:"Laminas\\Mvc"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"security-concerns",children:"Security concerns"}),"\n",(0,t.jsxs)(n.p,{children:["Don't use this module to secure your application! You must use a proper authorization module, like\n",(0,t.jsx)(n.a,{href:"https://github.com/bjyoungblood/BjyAuthorize",children:"BjyAuthorize"}),", ",(0,t.jsx)(n.a,{href:"https://github.com/LM-Commons/LmcRbacMvc",children:"LmcRbacMvc"})," or\n",(0,t.jsx)(n.a,{href:"https://github.com/spiffyjr/spiffy-authorize",children:"SpiffyAuthorize"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"LmcCors only allows to accept or refuse a cross-origin request."}),"\n",(0,t.jsx)(n.h2,{id:"custom-schemes",children:"Custom schemes"}),"\n",(0,t.jsxs)(n.p,{children:["Internally, LmcCors uses ",(0,t.jsx)(n.code,{children:"Laminas\\Uri\\UriFactory"})," class. If you are using custom schemes (for instance if you are\ntesting your API with some Google Chrome extensions), you need to add support for those schemes by adding them to\nthe ",(0,t.jsx)(n.code,{children:"UriFactory"})," config (please ",(0,t.jsx)(n.a,{href:"https://docs.laminas.dev/laminas-uri/usage/#creating-a-new-custom-class-uri",children:"refer to the doc"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.p,{children:["To register the ",(0,t.jsx)(n.code,{children:"chrome-extension"})," custom scheme in your API, simply add:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"use Laminas\\Uri\\UriFactory;\n\nUriFactory::registerScheme('chrome-extension', 'Laminas\\Uri\\Uri');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["to the ",(0,t.jsx)(n.code,{children:"onBootstrap()"})," method in ",(0,t.jsx)(n.code,{children:"module/Application/Module.php"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Registering the ",(0,t.jsx)(n.code,{children:"chrome-extension"})," custom scheme like this allows you to use Google Chrome extensions for testing your API."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(6540);const o={},r=t.createContext(o);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);